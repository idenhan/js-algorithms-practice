// Merge two sorted arrays in sorted order
// Merge two sorted arrays in sorted order
const merge = function (left, right) {
  let merged = [];
  let iL = 0,
    iR = 0;
  while (merged.length < left.length + right.length) {
    // Default to the left element for stability
    if (iR >= right.length || left[iL] <= right[iR]) {
      merged.push(left[iL]);
      iL += 1;
    } else {
      merged.push(right[iR]);
      iR += 1;
    }
  }
  return merged;
};

const mergeSort = function (array) {
  let lists = [];
  // Split array into sublists
  // Natural variant: split array into pre-sorted sublists
  let currentList = [];
  lists = [];
  for (let i = 0; i < array.length; i++) {
    if (currentList.length && array[i] < currentList[currentList.length - 1]) {
      lists.push(currentList);
      currentList = [];
    }
    currentList.push(array[i]);
  }
  lists.push(currentList);
  // Until the entire array is sorted
  while (lists.length > 1) {
    let newLists = [];
    // Merge all adjacent lists
    for (let i = 0; i < Math.floor(lists.length / 2); i++) {
      newLists.push(merge(lists[i * 2], lists[i * 2 + 1]));
    }
    // Include the leftover list if the number is odd
    if (lists.length % 2) {
      newLists.push(lists[lists.length - 1]);
    }
    lists = newLists;
  }
  // we have a single, fully sorted list
  return lists[0];
};

/* 
"합병 정렬" 알고리즘을 사용해 숫자들의 배열을 정렬하는 함수를 작성하세요.

합병 정렬(또는 Merge Sort)은 표준 라이브러리에서 정렬을 구현할 때 퀵 정렬이나 힙 정렬의 대안으로 사용하는 최적화된 정렬 알고리즘입니다.

합병 정렬은 다음과 같은 알고리즘을 사용합니다. 1. N의 길이를 가진 배열 리스트를 1의 길이를 가진 "부분 리스트"가 N개 모인 것으로 취급합니다. 
2. 인접한 부분 리스트들을 정렬하여 2의 길이를 가진 부분 리스트로 병합합니다. 3. 2의 길이를 가진 인접한 부분 리스트들을 4의 길이를 가진 부분 리스트로 합칩니다. 
4. 하나의 정렬된 리스트가 될 때까지 위 과정을 반복합니다. 5. N이 홀수라면, 첫 번째 병합 때 1의 길이를 가진 부분 리스트를 남깁니다.

이 알고리즘은 두 가지 방식으로 구현 가능합니다. 재귀적 접근(위->아래) 그리고 반복적 접근(아래->위)

반복적 접근 :
  1. 주어진 배열이 "정렬된" 부분 리스트로 나뉘어집니다.
  [4,7,4,3,9,1,2] -> [[4],[7],[4],[3],[9],[1],[2]]

  2. 인접한 부분 리스트 2개가 정렬된 부분 리스트로 병합됩니다.
  [[4],[7],[4],[3],[9],[1],[2]] -> [[4,7],[3,4],[1,9],[2]]

  2. 병합 과정 (반복) :
  [[4,7],[3,4],[1,9],[2]] -> [[3,4,4,7], [1,2,9]]

  2. 병합 과정 (반복) :
  [[3,4,4,7], [1,2,9]] -> [[1,2,3,4,4,7,9]]

  3. 마무리 : 정렬된 배열이 리턴됩니다.
  [1,2,3,4,4,7,9]

재귀적 접근 :

  1. 주어진 배열을 절반으로 나눕니다.
  [4, 7, 4, 3, 9, 1, 2] -> [4, 7, 4], [3, 9, 1, 2]

  2. 두 배열이 재귀적으로 정렬됩니다.
  [4, 7, 4] -> [4, 4, 7]
  [3, 9, 1, 2] -> [1, 2, 3, 9]

  3. 두 배열이 병합됩니다.
  [4, 7, 4], [3, 9, 1, 2] -> [1, 2, 3, 4, 4, 7, 9]

  2단계에서 재귀적으로 정렬하는 과정이 조금 이상하게 보일 수도 있습니다.
  이 과정을 좀 풀어서 설명드리겠습니다. 2번에서 나뉘어진 각각의 [4, 7, 4] [3, 9, 1, 2]에 대해서도
  1-3번의 과정이 재귀적으로 똑같이 진행됩니다.
  지금까지 재귀함수를 배우면서, 재귀함수란 문제를 잘게 쪼개어 각각의 문제에 대해 자기 자신을 호출하는
  함수라는 것을 배우셨을 것입니다. 핵심은 쪼개진 각각의 문제에 대해서도 똑같은 로직이 적용된다는 말이죠!

  1. 주어진 배열을 절반으로 나눕니다.
  [4, 7, 4] -> [4], [7, 4]

  2. 두 배열이 재귀적으로 정렬됩니다.
  [4] -> [4]
  [7, 4] -> [4, 7]

  3. 두 배열이 병합됩니다.
  [4], [4, 7] -> [4, 4, 7]

  이 과정의 2단계에서 나뉘어진 [4, 7]에 대해서도 재귀가 호출됩니다.
  [4]는 원소가 하나이기 때문에 정렬하지 않아도 되겠죠?

  1. 주어진 배열을 절반으로 나눕니다.
  [7, 4] -> [7], [4]

  2. 두 배열이 재귀적으로 정렬됩니다.
  [7] -> [7]
  [4] -> [4]

  3. 두 배열이 병합됩니다.
  [7], [4] -> [4, 7]

  여러분이 보시는 것처럼, 모든 재귀가 호출되고 나면 3단계에서 병합이 되기 때문에
  최종적으로 정렬된 하나의 배열이 결과로 리턴됩니다.

  시간 복잡도: 여러분이 작성한 알고리즘의 시간 복잡도는 어떻게 될까요? 병합 단계에서 삽입 정렬을 사용하여 구현할 수 있습니다. 
  이 경우 시간 복잡도는 훨씬 낮아지게 됩니다. 왜 그린 것일까요?

Advanced: 퀵 정렬에 비해 합병 정렬의 장점 중 하나는 안정적이라는 것입니다. 
(알고리즘에서 안정적이란 말은 "정렬되지 않은 상태에서 같은 값을 가진 원소들의 순서가, 정렬된 후에도 유지된다" 를 뜻합니다) 
이 문제는 정수들을 정렬할 때는 크게 상관없지만, 좀 더 복잡한 객체들을 정렬할 때는 중요한 얘기가 됩니다. 
여러분의 알고리즘은 제대로 구현된 합병 정렬처럼 안정적인가요?

NightMare: 여러분의 로직은 대개 들어온 배열이 완벽하게 정렬되지 않았다고 가정한 상태에서 정렬을 시작할 것입니다. 
그러나 실제로는 "완벽하게 정렬된 배열" 만큼이나 "완벽하게 정렬되지 않은 배열"도 까다로운 조건입니다. 정말 랜덤한 숫자들로 배열을 채워도, 
그 중에는 연속되는 정수들이 있기 마련이니까요. 한번 1단계에서 배열을 "길이가 1인 부분 리스트" 가 아닌, 
"최소한의 길이를 가진 정렬된 부분 리스트" 로 나누어 보세요. 그리고 평균 처리속도가 얼마나 빨라지는지 확인해 보세요!
*/
